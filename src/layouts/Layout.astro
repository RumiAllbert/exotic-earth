---
import { basics } from "@cv";
import Vengeance from "@/layouts/Vengeance.astro";
import ThemeSwitch from "@/components/ThemeSwitch.astro";
import KeyboardManager from '../components/KeyboardManager.astro';

interface Props {
	title: string;
	description?: string;
}

const { title, description = basics.summary } = Astro.props;

const { image, url, theme } = basics;

const ogImage = '/og-image.jpg';
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>{title}</title>
		<meta name="description" content={description} />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<link rel="canonical" href={Astro.url} />
		<link rel="preload" as="image" href={image} />

		<!-- Open Graph / Facebook -->
		<meta property="og:type" content="website" />
		<meta property="og:url" content={Astro.url} />
		<meta property="og:title" content={title} />
		<meta property="og:description" content={description} />
		<meta property="og:image" content={ogImage} />

		<!-- Twitter -->
		<meta property="twitter:card" content="summary_large_image" />
		<meta property="twitter:url" content={Astro.url} />
		<meta property="twitter:title" content={title} />
		<meta property="twitter:description" content={description} />
		<meta property="twitter:image" content={ogImage} />

		<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Itim" />

		<link rel="stylesheet" href="/themes/themes.css" />
		<Vengeance />
	</head>
	<body data-theme={theme} class="relative bg-skin-fill">
		<div class="absolute top-0 -z-10 h-full w-full print:hidden">
			<div class="bg-skin-hue/10 absolute bottom-auto left-[20%] right-auto top-0 h-[200px] w-[200px] -translate-x-[30%] translate-y-[20%] rounded-full blur-[80px] invert-0 dark:bg-white/5"></div>
		</div>
		<slot />
		<KeyboardManager />
		<ThemeSwitch />
		<style is:global>
			body,
			figure {
				margin: 0;
				padding: 0;
			}

			a {
				text-decoration: none;
				}
			ul {
				list-style: none;
				margin: 0;
				padding: 0;
			}

			*,
			*::before,
			*::after {
				box-sizing: border-box;
			}

			h1,
			h2,
			h3,
			h4 {
				@apply text-skin-base;
				margin: 0;
				font-family:
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					"Segoe UI",
					Roboto,
					Oxygen,
					Ubuntu,
					Cantarell,
					"Open Sans",
					"Helvetica Neue",
					sans-serif;
			}

			p {
				@apply text-sm text-skin-muted;
				line-height: 1.5;
				text-wrap: pretty;
			}

			.print {
				display: none !important;
			}

			.dev * {
				@apply border border-red-500/50 bg-red-500/5;
			}
			#hotkeypad [data-backdrop] {
				@apply !bg-zinc-800 !opacity-80;
			}

			@media print {
				.no-print {
					display: none !important;
				}

				.print {
					display: block !important;
				}

				astro-dev-toolbar {
					display: none !important;
				}

				article {
					break-inside: avoid;
				}
			}

			.core-competency {
				@apply bg-blue-200 text-blue-800 text-base;
			}

			:global(.dark) .core-competency {
				@apply bg-blue-800 text-blue-200;
			}

			#loader {
				transition: opacity 0.5s ease-out;
			}

			#loader.fade-out {
				opacity: 0;
			}

			.hypergraph-loader {
				animation: rotate 10s linear infinite;
			}

			@keyframes rotate {
				from {
					transform: rotate(0deg);
				}
				to {
					transform: rotate(360deg);
				}
			}

			#main-content {
				opacity: 0;
				transition: opacity 0.5s ease-out, filter 0.5s ease-out;
			}

			body {
				overflow-x: hidden;
			}
		</style>
		<script>
			function createHypergraph() {
				const svg = document.querySelector('.hypergraph-loader') as SVGSVGElement;
				svg.setAttribute('viewBox', '-10 -10 220 220'); // Add padding to the viewBox
				svg.setAttribute('width', '200');
				svg.setAttribute('height', '200');
				const numNodes = 30;
				const numEdges = 30;
				const nodes: Array<{
					x: number;
					y: number;
					dx: number;
					dy: number;
					radius: number;
					pulseSpeed: number;
					pulseOffset: number;
				}> = [];

				// Create gradient
				const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
				gradient.setAttribute('id', 'nodeGradient');
				gradient.innerHTML = `
					<stop offset="0%" stop-color="rgba(168, 85, 247, 0.8)" />
					<stop offset="100%" stop-color="rgba(107, 33, 168, 0.8)" />
				`;
				svg.appendChild(gradient);

				// Add glow effect
				const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
				defs.innerHTML = `
					<filter id="glow">
						<feGaussianBlur stdDeviation="1.5" result="coloredBlur"/>
						<feMerge>
							<feMergeNode in="coloredBlur"/>
							<feMergeNode in="SourceGraphic"/>
						</feMerge>
					</filter>
				`;
				svg.appendChild(defs);

				// Create nodes
				for (let i = 0; i < numNodes; i++) {
					const x = Math.random() * 200;
					const y = Math.random() * 200;
					const baseRadius = 3;
					nodes.push({ 
						x, 
						y, 
						dx: (Math.random() - 0.5) * 0.5, 
						dy: (Math.random() - 0.5) * 0.5,
						radius: baseRadius,
						pulseSpeed: Math.random() * 0.05 + 0.02,
						pulseOffset: Math.random() * Math.PI * 2
					});
					const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
					circle.setAttribute('cx', x.toString());
					circle.setAttribute('cy', y.toString());
					circle.setAttribute('r', baseRadius.toString());
					circle.setAttribute('fill', 'url(#nodeGradient)');
					circle.setAttribute('filter', 'url(#glow)');
					svg.appendChild(circle);
				}

				// Create edges
				const edges: Array<{
					path: SVGPathElement;
					start: typeof nodes[0];
					end: typeof nodes[0];
				}> = [];
				for (let i = 0; i < numEdges; i++) {
					const start = nodes[Math.floor(Math.random() * nodes.length)];
					const end = nodes[Math.floor(Math.random() * nodes.length)];
					const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
					path.setAttribute('d', `M${start.x},${start.y} L${end.x},${end.y}`);
					path.setAttribute('stroke', 'rgba(168, 85, 247, 0.2)'); // Lighter, more transparent purple for unloaded edges
					path.setAttribute('stroke-width', '2');
					path.setAttribute('fill', 'none');
					svg.appendChild(path);
					edges.push({ path, start, end });
				}

				return { nodes, edges };
			}

			function animateHypergraph(nodes: ReturnType<typeof createHypergraph>['nodes'], edges: ReturnType<typeof createHypergraph>['edges']) {
				let time = 0;
				function update() {
					time += 0.016;

					nodes.forEach(node => {
						node.x += node.dx;
						node.y += node.dy;
						if (node.x < 0 || node.x > 200) node.dx *= -1;
						if (node.y < 0 || node.y > 200) node.dy *= -1;
						node.radius = 3 + Math.sin(time * node.pulseSpeed + node.pulseOffset) * 0.5;
					});

					const circles = document.querySelectorAll('.hypergraph-loader circle');
					circles.forEach((circle, i) => {
						circle.setAttribute('cx', nodes[i].x.toString());
						circle.setAttribute('cy', nodes[i].y.toString());
						circle.setAttribute('r', nodes[i].radius.toString());
					});

					edges.forEach(edge => {
						edge.path.setAttribute('d', `M${edge.start.x},${edge.start.y} L${edge.end.x},${edge.end.y}`);
					});

					requestAnimationFrame(update);
				}

				update();
			}

			function animateLoader(nodes: ReturnType<typeof createHypergraph>['nodes'], edges: ReturnType<typeof createHypergraph>['edges']) {
				const minDuration = 2000;
				const maxDuration = 3000;
				const duration = Math.random() * (maxDuration - minDuration) + minDuration;
				const interval = 50;
				const steps = duration / interval;
				let currentStep = 0;

				disableScroll();

				const animationInterval = setInterval(() => {
					currentStep++;
					const progress = currentStep / steps;

					edges.forEach((edge, index) => {
						if (index / edges.length < progress) {
							edge.path.setAttribute('stroke', 'rgba(107, 33, 168, 1)'); // Dark purple for loaded edges
							edge.path.setAttribute('stroke-width', '3');
							edge.path.setAttribute('filter', 'url(#glow)');
						}
					});

					const mainContent = document.getElementById('main-content');
					if (mainContent) {
						const blurAmount = 5 * (1 - progress);
						mainContent.style.filter = `blur(${blurAmount}px)`;
					}

					if (progress >= 1) {
						clearInterval(animationInterval);
						convergenceAnimation(nodes, edges);
					}
				}, interval);
			}

			function convergenceAnimation(nodes: ReturnType<typeof createHypergraph>['nodes'], edges: ReturnType<typeof createHypergraph>['edges']) {
				const centerX = 100;
				const centerY = 100;
				const duration = 1000; // 1 second
				const fps = 60;
				const totalFrames = duration / (1000 / fps);
				let currentFrame = 0;

				const animationInterval = setInterval(() => {
					currentFrame++;
					const progress = currentFrame / totalFrames;

					nodes.forEach(node => {
						node.x = node.x + (centerX - node.x) * progress;
						node.y = node.y + (centerY - node.y) * progress;
						node.radius = node.radius * (1 - progress);
					});

					const circles = document.querySelectorAll('.hypergraph-loader circle');
					circles.forEach((circle, i) => {
						circle.setAttribute('cx', nodes[i].x.toString());
						circle.setAttribute('cy', nodes[i].y.toString());
						circle.setAttribute('r', nodes[i].radius.toString());
						circle.setAttribute('opacity', (1 - progress).toString());
					});

					edges.forEach(edge => {
						edge.path.setAttribute('d', `M${edge.start.x},${edge.start.y} L${edge.end.x},${edge.end.y}`);
						edge.path.setAttribute('opacity', (1 - progress).toString());
					});

					if (progress >= 1) {
						clearInterval(animationInterval);
						const loader = document.getElementById('loader');
						if (loader) {
							loader.classList.add('fade-out');
							setTimeout(() => {
								if (loader) loader.style.display = 'none';
								const mainContent = document.getElementById('main-content');
								if (mainContent) mainContent.style.filter = 'none';
								enableScroll();
							}, 500);
						}
					}
				}, 1000 / fps);
			}

			window.addEventListener('load', () => {
				const { nodes, edges } = createHypergraph();
				animateHypergraph(nodes, edges);
				animateLoader(nodes, edges);
				
				const mainContent = document.getElementById('main-content');
				if (mainContent) {
					mainContent.style.opacity = '1';
					mainContent.style.filter = 'blur(5px)';
				}
			});

			function disableScroll() {
				document.body.style.overflow = 'hidden';
			}

			function enableScroll() {
				document.body.style.overflow = '';
			}
		</script>
		<style>
			#loader {
				position: fixed;
				top: 0;
				left: 0;
				width: 100vw;
				height: 100vh;
				display: flex;
				justify-content: center;
				align-items: center;
				background-color: var(--color-fill);
			}

			.hypergraph-loader {
				width: 200px;
				height: 200px;
				animation: rotate 10s linear infinite;
			}

			@keyframes rotate {
				from {
					transform: rotate(0deg);
				}
				to {
					transform: rotate(360deg);
				}
			}
		</style>
	</body>
</html>
